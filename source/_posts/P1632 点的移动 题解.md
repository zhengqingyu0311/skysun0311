---
abbrlink: ''
author: 王轶
categories: []
date: '2023-05-21 22:06:28'
excerpt: 看完题目，来分析一下： 从一道易于理解的题出发： 求 $|x-1|+|x-2|+|x-3|+|x-4|+|x-5|$ 的最小值。 显然，从绝对值的几何意义出发，不难得到，当
  $x=3$ 时，原式有最小值，最小值为 $6$。而 $3$，正是 $[1,2,3,4,5]$ 的中位数。 衍生到此题，从 $|x_0-x_1|+|y_0-y_1|$
  入手，或许能有所体悟。 在复杂的情况下，试构造简例理解： 在...
keywords: ''
mathjax: true
tags: []
title: P1632 点的移动 题解
updated: Sun, 21 May 2023 14:06:43 GMT
---
看完题目，来分析一下：

从一道易于理解的题出发：

求 $|x-1|+|x-2|+|x-3|+|x-4|+|x-5|$ 的最小值。

显然，从绝对值的几何意义出发，不难得到，当 $x=3$ 时，原式有最小值，最小值为 $6$。而 $3$，正是 $[1,2,3,4,5]$ 的中位数。

衍生到此题，从 $|x_0-x_1|+|y_0-y_1|$ 入手，或许能有所体悟。

在复杂的情况下，试构造简例理解：
在直角坐标系 $\text{XoY}$ 中，点 $A=(5,3), B=(6,1)$，则"最小代价"如何思考?

不难构造当 $A,B$ 移动到可行解 $(5,1)$ 或 $(6,3)$ 时，代价最小，为 $3$。而它们的横纵坐标，实源自 $A,B$ 的横纵坐标。

试将此特点运用至样例一：

```
4
15 14
15 16
14 15
16 15
```

设 $A=(15,14),B=(15,16),C=(14,15),D=(16,15)$ ，试求 $AB,AC,AD,BC,BD,CD$ 的"可行解"并作于直角坐标系中。

在"可行解"的连线段上的所有点，俱为 $A,B,C,D$ 的“可行解”。联系开篇的绝对值题例，不难发现，此连线段定然经过 $A,B,C,D$ 其一点。

此与中位数有异曲同工之妙，问题就此破解。

将 $A,B,C,D$ 的横纵坐标分别置于序列 $a=[15,15,14,16] , b=[14,16,15,15]$ 中。

暴力 $a_1,a_2,a_3,a_4,b_1,b_2,b_3,b_4$ 并组合，同时枚举 $A,B,C,D$ 分别求其与 $a_i,b_j$ 的"最短距离"，（连线段定然经过 $ A,B,C,D $ 其一点）进行排序后求前缀和。$f$ 数组保留最优解。

这个题无非是把一维变成二维。再看数据也是非常的小：$1\leq n \leq50$，这么小的数据用 $O(n^4)$ 的复杂度都不会超时，所以只要暴力枚举 $x$ 和 $y$ 就行了。
用两层循环枚举 $x$ 和 $y$，里面套一层循环计算两点之间的距离，再将距离排序，求前缀和，最后用一层循环更新答案。完美的过程，虽然是暴力，但这么小的数据不可能超时。

话不多说，直接上代码：

CODE：

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int n;
int a[55],b[55],d[55],f[55];
int main(){
	memset(f,0x3f,sizeof f);//f数组初始化 
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d%d",&a[i],&b[i]);//输入 
	for(int i=1;i<=n;i++)//三层循环暴力 
		for(int j=1;j<=n;j++){
			for(int k=1;k<=n;k++)d[k]=abs(a[k]-a[i])+abs(b[k]-b[j]);//计算两点之间的距离 
			sort(d+1,d+n+1);//d数组排序 
			for(int k=1;k<=n;k++){
				d[k]+=d[k-1];
				f[k]=min(f[k],d[k]);//dp计算最小距离 
			}
		}
	for(int i=1;i<=n;i++)printf("%d\n",f[i]);//输出 
	return 0;
}
```
