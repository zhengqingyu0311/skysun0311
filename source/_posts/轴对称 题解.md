---
abbrlink: P9198-Solve
categories:
- - 编程
- - OI
- - C++
date: '2023-05-08 21:52:33'
keywords: 洛谷P9198 轴对称 题解
mathjax: true
tags:
- 洛谷
- 月赛
- 题解
- 编程
- ' 算法'
- C++
title: 洛谷P9198 轴对称 题解
updated: Fri, 12 May 2023 22:46:19 GMT
---
# 题目分析

这道题目要求我们在每次修改一个像素块的 $\texttt{RGB}$ 值后，判断图片是否左右对称。我们可以用一个二维结构体数组来存储图片的像素信息，每个元素是一个三元组（结构体实现）表示 $\texttt{RGB}$ 值。然后我们可以用一个函数来判断图片是否左右对称。每次修改一个像素块后，我们就用判断函数检查整幅图是否仍然左右对称，如果不是，就返回假；如果是，就就返回为真。最后，根据函数返回结果输出“ $\texttt{Yes}$ ”或“ $\texttt{No}$ ”即可。

## 推理过程

**根据题目给出的对称判定方法可以编写出判断函数：**

> 左右对称：即对于任何的 $i,j$ ，总满足第 $i$ 行第 $j$ 列的像素与第 $i$ 行第 $m-j+1$ 列的像素的 RGB 值相等。

现在我们对其进行模拟：
如果一幅图片不是对称的，（如图）：

![Picture](https://cdn.luogu.com.cn/upload/image_hosting/a54zswz8.png)

假设第一个像素 $i$ 为 $1$ ，则 $\mathit{a}_{i,j}=\mathit{a}_{1,4}=(1,0,1)$ ，而 $\mathit{a}_{i,m-j+1}=\mathit{a}_{1,9-4+1}=\mathit{a}_{1,6}=(1,0,2)$ ， $\mathit{a}_{i,j}≠\mathit{a}_{i,m-j+1}$ ，故不为轴对称图形。

因此，我们可以写出判断函数代码：

```cpp
//定义一个函数，检查图片是否关于轴对称
bool check(){
	//遍历每个像素点
	for(LL i=1;i<=n;i++)
		for(LL j=1;j<=m;j++){
			//如果当前像素点和对称位置的像素点颜色不同（RGB的三位数字），返回false
			if(a[i][j].r!=a[i][m-j+1].r||a[i][j].g!=a[i][m-j+1].g||a[i][j].b!=a[i][m-j+1].b)return 0;
		}
	return 1;//否则返回true
}
```

#### **复杂度分析**

时间复杂度：每次修改一个像素块后，我们需要检查整幅图片是否左右对称，需要 $O(nm)$ 的时间。总共有 $q$ 次操作，所以总时间复杂度是 $O(qnm)$ ，时间复杂度较大，但可以通过本题的数据。

空间复杂度：我们需要存储图片的像素信息，总空间复杂度是 $O(nm)$ 。

### 代码：

```cpp
#include<bits/stdc++.h>
#define inf 0x7fffffff
#define LL long long//宏定义
const int mod=256;//定义一个mod并在后面使用
using namespace std;
LL n,m,q;
//定义一个结构体，表示RGB颜色
//（r,g,b分别表示第一、二、三个数）
struct RGB{
	LL r,g,b;//分别表示每个像素第一个、第二个和第三个数字的值
}a[1010][1010];//定义一个二维数组，表示图片的像素

//定义一个函数，检查图片是否关于轴对称
bool check(){
	//遍历每个像素点
	for(LL i=1;i<=n;i++)
		for(LL j=1;j<=m;j++){
			//如果当前像素点和对称位置的像素点颜色不同，返回false
			if(a[i][j].r!=a[i][m-j+1].r||a[i][j].g!=a[i][m-j+1].g||a[i][j].b!=a[i][m-j+1].b)return 0;
		}
	return 1;//否则返回true
}
int main(){
	ios::sync_with_stdio(0);//小技巧：加速输入输出流
	//输入图片的行数、列数和操作次数
	cin>>n>>m>>q;
	//循环处理每次操作
	for(LL cnt=1;cnt<=q;cnt++){
		//输入操作的行号、列号、颜色类型和增加量
		LL i,j,t,c;
		cin>>i>>j>>t>>c;
		//根据颜色类型更新对应的颜色值，并取模以保证在0到255之间
		if(t==1){a[i][j].r+=c;a[i][j].r%=mod;}
		if(t==2){a[i][j].g+=c;a[i][j].g%=mod;}
		if(t==3){a[i][j].b+=c;a[i][j].b%=mod;}

		if(check())cout<<"Yes\n";else cout<<"No\n";//检查图片是否对称，如果是轴对称图形，输出“Yes”，否则，输出：“No”
	}
	return 0;
}
```

---
